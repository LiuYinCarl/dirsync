# todo list




## 服务端
[] 解析命令行给出的文件路径，遍历文件路径，将所有文件的结构保存到一个文本文件中

[] 开启http服务器，将保存有目录下所有文件路径信息的文件发送给客户端

[] 接受客户端的请求，将客户端请求的文件发送给客户端



## 客户端
[] 向服务端请求保存有所有文件路径的文件

[] 收到保存有所有文件路径的文件后，开启多线程向客户端请求这些文件

[] 根据收到的文件，将文件保存在对应的位置，还原服务端的目录结构

[] 客户端需要保存上一次传输完成的文件位置，这样子可以用于断点续传



## 含有目录下所有文件路径的文件格式

其中 D 代表文件夹, F 代表文件 

编号    类型    路径

1       D       xxx/xxx/

2       F       xxx/xxx/xxx.data




## 传输协议的设计

1. 客户端 --> 服务端：filename文件名
2. 客户端 <-- 服务端：exist:[y/n] size:[] mode:[]
3. 客户端 --> 服务端: ready:[y/n]
4. 客户端 <-- 服务端: 发送文件内容
5. 客户端 --> 服务端: saveall:[y/n]




**协议的公共头**
3 字节填充 "dir"
1 字节 填充一个数字 表示这是哪条协议

**协议的公共尾**
4 字节的 crc 校验代码，校验协议内容，协议接收者收到一条协议时，先校验 crc，
再处理具体的协议内容


**协议 1**
协议作用：客户端给服务端传输一个文件路径

2 字节的长度 n, 表示路径的长度
n 个字符填充路径

**协议 2**
协议作用：作为协议 1 的回复，服务端给客户端传递一个文件的信息

1 字节的字符 'Y' 或者 'N', 表示文件是否存在
如果上一个字节是 'N'，后面没有内容。如果上一个字节是 'Y'，后面内容如下
4 字节 文件长度


**协议 3**
协议作用：告诉对端自己已经是否已经准备好了

1 字节的字符 'Y' 或者 'N', 'Y' 表示自己已经准备好了， 'N' 表示取消本次通信

**协议 4**
协议作用：告诉对端自己已经接收文件完成，或者接受文件失败（如果失败直接启动重传）
1 字节的字符 'Y' 或者 'N'，'Y' 表示自己已经接收文件完成，'N' 表示接收文件失败，
不论收到的内容如何，对端都可以认为这次传输已经完成了







第一步是客户端给服务端发送一个需要下载的文件名。这条协议的格式是

每条协议的标记
 



2字节的标志 p1 (proto1)
16字节的长度标志 ()
文件名






## 参考
[1] 终端输出 https://www.infoq.cn/article/jjqljfltft8b4ogijoof

[2] bufio库的使用 https://zhuanlan.zhihu.com/p/73690883

[3] golang实现基于TCP协议的文件传输 https://studygolang.com/articles/22198

[4] go语言中int和byte转换方式 https://juejin.cn/post/6845166890977853453

[5] go 自定义包引入，报错包找不到的问题 https://segmentfault.com/q/1010000039302162?utm_source=sf-similar-question

